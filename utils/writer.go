package utils

import (
	"fmt"
	"os"
	"sort"
	"strings"

	"palo-pan-parsing/models"
)

// WriteResults writes results to file in a structured YAML-like format
func WriteResults(outputFile, addressName string, matchingLines []string, itemsDict *models.FormattedResults) error {
	// Ensure outputs directory exists
	if err := EnsureOutputsDir(); err != nil {
		return fmt.Errorf("error creating outputs directory: %w", err)
	}
	
	// Prepend outputs/ to the file path if not already there
	if !strings.HasPrefix(outputFile, "outputs/") {
		outputFile = "outputs/" + outputFile
	}
	
	file, err := os.Create(outputFile)
	if err != nil {
		return fmt.Errorf("error creating output file: %w", err)
	}
	defer file.Close()

	// Enhanced header with metadata
	fmt.Fprintf(file, "# ═══════════════════════════════════════════════════════════════\n")
	fmt.Fprintf(file, "# PAN Log Parser Analysis Report v2.0 (Go Edition)\n")
	fmt.Fprintf(file, "# ═══════════════════════════════════════════════════════════════\n")
	fmt.Fprintf(file, "# Target Address Object: %s\n", addressName)
	fmt.Fprintf(file, "# Configuration Lines Found: %d\n", len(matchingLines))

	totalRelationships := len(itemsDict.DeviceGroups) + len(itemsDict.DirectSecurityRules) +
		len(itemsDict.IndirectSecurityRules) + len(itemsDict.AddressGroups) +
		len(itemsDict.NATRules) + len(itemsDict.ServiceGroups) + len(itemsDict.RedundantAddresses)
	fmt.Fprintf(file, "# Total Relationships: %d\n", totalRelationships)
	fmt.Fprintf(file, "# ═══════════════════════════════════════════════════════════════\n\n")

	// Matching configuration lines section
	fmt.Fprintf(file, "# MATCHING CONFIGURATION LINES\n")
	fmt.Fprintf(file, "Found [%d] lines containing '%s':\n", len(matchingLines), addressName)
	fmt.Fprintf(file, "---\n")
	if len(matchingLines) > 0 {
		for i, line := range matchingLines {
			fmt.Fprintf(file, "%d.%s\n", i+1, line)
		}
	} else {
		fmt.Fprintf(file, "No matching lines found\n")
	}
	fmt.Fprintf(file, "---\n")

	// Category sections

	// Write each category
	writeCategory(file, "Device Groups", itemsDict.DeviceGroups)
	writeSecurityRulesCategory(file, "Direct Security Rules", itemsDict.DirectSecurityRules, matchingLines)
	writeSecurityRulesCategory(file, "Indirect Security Rules (via Address Groups)", itemsDict.IndirectSecurityRules, matchingLines)
	writeAddressGroupsCategory(file, addressName, itemsDict.AddressGroups)
	writeCategory(file, "NAT Rules", itemsDict.NATRules)
	writeCategory(file, "Service Groups", itemsDict.ServiceGroups)
	writeRedundantAddressesCategory(file, itemsDict.RedundantAddresses)

	// Add footer
	fmt.Fprintf(file, "# ═══════════════════════════════════════════════════════════════\n")
	fmt.Fprintf(file, "# Analysis Complete\n")
	fmt.Fprintf(file, "# Generated by: PAN Log Parser Tool v2.0 (Go Edition)\n")
	fmt.Fprintf(file, "# Advanced Palo Alto Networks Configuration Analysis\n")
	fmt.Fprintf(file, "# ═══════════════════════════════════════════════════════════════\n")

	return nil
}

func writeCategory(file *os.File, category string, items []string) {
	count := len(items)
	fmt.Fprintf(file, "# %s\n", strings.ToUpper(category))
	fmt.Fprintf(file, "Found [%d] item", count)
	if count != 1 {
		fmt.Fprintf(file, "s")
	}
	fmt.Fprintf(file, ":\n")
	fmt.Fprintf(file, "---\n")
	if count > 0 {
		for i, item := range items {
			fmt.Fprintf(file, "%d. %s\n", i+1, item)
		}
	} else {
		fmt.Fprintf(file, "None discovered\n")
	}
	fmt.Fprintf(file, "---\n")
}

func writeSecurityRulesCategory(file *os.File, category string, items []string, matchingLines []string) {
	count := len(items)
	fmt.Fprintf(file, "# %s\n", strings.ToUpper(category))
	fmt.Fprintf(file, "Found [%d] item", count)
	if count != 1 {
		fmt.Fprintf(file, "s")
	}
	fmt.Fprintf(file, ":\n")
	fmt.Fprintf(file, "---\n")

	if count > 0 {
		// Group rules by device group
		rulesByDG := make(map[string][]models.RuleContext)
		for _, item := range items {
			parts := strings.Split(item, " (Device Group: ")
			if len(parts) == 2 {
				ruleName := parts[0]
				dgPart := parts[1]

				// Remove only the final closing parenthesis
				dgPart = strings.TrimSuffix(dgPart, ")")

				var deviceGroup, context string
				if strings.Contains(dgPart, ", ") {
					dgAndContext := strings.SplitN(dgPart, ", ", 2)
					deviceGroup = dgAndContext[0]
					context = dgAndContext[1]
				} else {
					deviceGroup = dgPart
				}

				rulesByDG[deviceGroup] = append(rulesByDG[deviceGroup], models.RuleContext{
					Name:    ruleName,
					Context: context,
				})
			}
		}

		// Sort device groups for consistent output
		var deviceGroups []string
		for dg := range rulesByDG {
			deviceGroups = append(deviceGroups, dg)
		}
		sort.Strings(deviceGroups)

		// Create numbered list similar to address groups format
		itemCount := 1
		for _, dg := range deviceGroups {
			rules := rulesByDG[dg]
			for _, rule := range rules {
				fmt.Fprintf(file, "%d. %s (device-group - %s):\n", itemCount, rule.Name, dg)
				
				// Find the original command line for this rule
				var commandLine string
				for _, line := range matchingLines {
					if strings.Contains(line, "security") && strings.Contains(line, "rules") && 
					   strings.Contains(line, rule.Name) && strings.Contains(line, dg) {
						commandLine = line
						break
					}
				}
				
				if commandLine != "" {
					fmt.Fprintf(file, "   └─ Command: %s\n", commandLine)
				}
				
				if rule.Context != "" {
					fmt.Fprintf(file, "   └─ Context: %s\n", rule.Context)
				} else {
					fmt.Fprintf(file, "   └─ Context: direct reference\n")
				}
				fmt.Fprintf(file, "   └─ Device Group: %s\n", dg)
				itemCount++
			}
		}
	} else {
		fmt.Fprintf(file, "None discovered\n")
	}
	fmt.Fprintf(file, "---\n")
}

func writeAddressGroupsCategory(file *os.File, addressName string, groups []models.AddressGroup) {
	count := len(groups)
	fmt.Fprintf(file, "# ADDRESS GROUPS\n")
	fmt.Fprintf(file, "Found [%d] items containing '%s':\n", count, addressName)
	fmt.Fprintf(file, "---\n")
	if count > 0 {
		for i, group := range groups {
			if group.Context == "shared" {
				fmt.Fprintf(file, "%d. %s (shared scope):\n", i+1, group.Name)
				fmt.Fprintf(file, "   └─ Command: set shared address-group %s static %s\n", group.Name, group.Definition)
				fmt.Fprintf(file, "   └─ Members: %s\n", group.Definition)
			} else {
				fmt.Fprintf(file, "%d. %s (device-group - %s):\n", i+1, group.Name, group.DeviceGroup)
				fmt.Fprintf(file, "   └─ Command: set device-group %s address-group %s static %s\n", group.DeviceGroup, group.Name, group.Definition)
				fmt.Fprintf(file, "   └─ Members: %s\n", group.Definition)
			}
		}
	} else {
		fmt.Fprintf(file, "None discovered\n")
	}
	fmt.Fprintf(file, "---\n")
}

func writeRedundantAddressesCategory(file *os.File, addresses []models.RedundantAddress) {
	count := len(addresses)
	fmt.Fprintf(file, "# REDUNDANT ADDRESSES\n")
	fmt.Fprintf(file, "Found [%d] items with identical ip/netmask:\n", count)
	fmt.Fprintf(file, "---\n")
	if count > 0 {
		for i, addr := range addresses {
			fmt.Fprintf(file, "%d. %s:\n", i+1, addr.Name)
			fmt.Fprintf(file, "   └─ IP/Netmask: %s\n", addr.IPNetmask)
			fmt.Fprintf(file, "   └─ Scope: %s\n", addr.DeviceGroup)
			fmt.Fprintf(file, "   └─ Note: Same IP as target address - potential duplicate\n")
		}
	} else {
		fmt.Fprintf(file, "None discovered\n")
	}
	fmt.Fprintf(file, "---\n")
}

// WriteAddressGroupCommands writes generated commands to a YAML file
func WriteAddressGroupCommands(outputFile, originalAddress, newAddressName string, commands []string, addressGroups []models.AddressGroup) error {
	// Ensure outputs directory exists
	if err := EnsureOutputsDir(); err != nil {
		return fmt.Errorf("error creating outputs directory: %w", err)
	}
	
	// Prepend outputs/ to the file path if not already there
	if !strings.HasPrefix(outputFile, "outputs/") {
		outputFile = "outputs/" + outputFile
	}
	
	file, err := os.Create(outputFile)
	if err != nil {
		return fmt.Errorf("error creating commands file: %w", err)
	}
	defer file.Close()

	// Enhanced header with metadata
	fmt.Fprintf(file, "# ═══════════════════════════════════════════════════════════════\n")
	fmt.Fprintf(file, "# PAN Address Group Commands Generator v2.0 (Go Edition)\n")
	fmt.Fprintf(file, "# ═══════════════════════════════════════════════════════════════\n")
	fmt.Fprintf(file, "# Original Address Object: %s\n", originalAddress)
	fmt.Fprintf(file, "# New Address Object: %s\n", newAddressName)
	fmt.Fprintf(file, "# Address Groups Found: %d\n", len(addressGroups))
	fmt.Fprintf(file, "# Commands Generated: %d\n", len(commands))
	fmt.Fprintf(file, "# ═══════════════════════════════════════════════════════════════\n\n")

	// Address groups details section in results.yml style
	fmt.Fprintf(file, "# SOURCE ADDRESS GROUPS\n")
	fmt.Fprintf(file, "Found [%d] address group", len(addressGroups))
	if len(addressGroups) != 1 {
		fmt.Fprintf(file, "s")
	}
	fmt.Fprintf(file, " containing '%s':\n", originalAddress)
	fmt.Fprintf(file, "---\n")

	if len(addressGroups) > 0 {
		for _, group := range addressGroups {
			if group.Context == "shared" {
				fmt.Fprintf(file, "%s (shared scope):\n", group.Name)
				fmt.Fprintf(file, "   └─ Original Command: set shared address-group %s static %s\n", group.Name, group.Definition)
				fmt.Fprintf(file, "   └─ New Command: set shared address-group %s static %s\n", group.Name, newAddressName)
				fmt.Fprintf(file, "   └─ Members: %s\n", group.Definition)
			} else {
				fmt.Fprintf(file, "%s (device-group - %s):\n", group.Name, group.DeviceGroup)
				fmt.Fprintf(file, "   └─ Original Command: set device-group %s address-group %s static %s\n", group.DeviceGroup, group.Name, group.Definition)
				fmt.Fprintf(file, "   └─ New Command: set device-group %s address-group %s static %s\n", group.DeviceGroup, group.Name, newAddressName)
				fmt.Fprintf(file, "   └─ Members: %s\n", group.Definition)
			}
		}
	} else {
		fmt.Fprintf(file, "None discovered\n")
	}
	fmt.Fprintf(file, "---\n")

	// Usage instructions section in results.yml style
	fmt.Fprintf(file, "# USAGE INSTRUCTIONS\n")
	fmt.Fprintf(file, "Found [4] steps for applying address group commands:\n")
	fmt.Fprintf(file, "---\n")
	fmt.Fprintf(file, "1. Create the new address object '%s' with appropriate IP/FQDN configuration\n", newAddressName)
	fmt.Fprintf(file, "2. Copy the commands from the 'GENERATED CONFIGURATION COMMANDS' section below\n")
	fmt.Fprintf(file, "3. Paste them into your PAN configuration interface or CLI\n")
	fmt.Fprintf(file, "4. Commit the changes to apply the new address group memberships\n")
	fmt.Fprintf(file, "---\n")

	// Commands section in results.yml style (moved after usage instructions)
	fmt.Fprintf(file, "# GENERATED CONFIGURATION COMMANDS\n")
	fmt.Fprintf(file, "Found [%d] command", len(commands))
	if len(commands) != 1 {
		fmt.Fprintf(file, "s")
	}
	fmt.Fprintf(file, " to add '%s' to same address groups as '%s':\n", newAddressName, originalAddress)
	fmt.Fprintf(file, "---\n")

	if len(commands) > 0 {
		for _, command := range commands {
			fmt.Fprintf(file, "%s\n", command)
		}
	} else {
		fmt.Fprintf(file, "None generated\n")
	}
	fmt.Fprintf(file, "---\n")

	// Add footer
	fmt.Fprintf(file, "# ═══════════════════════════════════════════════════════════════\n")
	fmt.Fprintf(file, "# Commands Generation Complete\n")
	fmt.Fprintf(file, "# Generated by: PAN Log Parser Tool v2.0 (Go Edition)\n")
	fmt.Fprintf(file, "# Advanced Palo Alto Networks Configuration Analysis\n")
	fmt.Fprintf(file, "# ═══════════════════════════════════════════════════════════════\n")

	return nil
}

// WriteCleanupCommands writes redundant address cleanup commands to file in a structured YAML-like format
func WriteCleanupCommands(outputFile string, commands *models.CleanupCommands) error {
	// Ensure outputs directory exists
	if err := EnsureOutputsDir(); err != nil {
		return fmt.Errorf("error creating outputs directory: %w", err)
	}
	
	// Prepend outputs/ to the file path if not already there
	if !strings.HasPrefix(outputFile, "outputs/") {
		outputFile = "outputs/" + outputFile
	}
	
	file, err := os.Create(outputFile)
	if err != nil {
		return fmt.Errorf("error creating cleanup commands file: %w", err)
	}
	defer file.Close()

	// Header in results.yml style
	fmt.Fprintf(file, "# ═══════════════════════════════════════════════════════════════\n")
	fmt.Fprintf(file, "# PAN Redundant Address Cleanup Commands v2.0 (Go Edition)\n")
	fmt.Fprintf(file, "# ═══════════════════════════════════════════════════════════════\n")
	fmt.Fprintf(file, "# Target Address: %s\n", commands.TargetAddress)
	fmt.Fprintf(file, "# Redundant Addresses: %s\n", strings.Join(commands.RedundantAddresses, ", "))
	fmt.Fprintf(file, "# Total Commands: %d\n", commands.TotalCommands)
	fmt.Fprintf(file, "# WARNING: Test in non-production environment first!\n")
	fmt.Fprintf(file, "# ═══════════════════════════════════════════════════════════════\n\n")

	// Group commands by section
	commandsBySection := make(map[string][]models.CleanupCommand)
	for _, command := range commands.Commands {
		commandsBySection[command.Section] = append(commandsBySection[command.Section], command)
	}

	// Define section order
	sectionOrder := []string{"target_creation", "address_groups", "security_rules", "nat_rules", "definitions"}

	// Write step descriptions at the top
	stepNum := 1
	for _, section := range sectionOrder {
		sectionCommands, exists := commandsBySection[section]
		if !exists || len(sectionCommands) == 0 {
			continue
		}

		// Get section title for steps
		var sectionTitle string
		switch section {
		case "target_creation":
			sectionTitle = fmt.Sprintf("STEP %d: CREATE TARGET ADDRESS (if needed)", stepNum)
		case "address_groups":
			sectionTitle = fmt.Sprintf("STEP %d: UPDATE ADDRESS GROUPS", stepNum)
		case "security_rules":
			sectionTitle = fmt.Sprintf("STEP %d: UPDATE SECURITY RULES", stepNum)
		case "nat_rules":
			sectionTitle = fmt.Sprintf("STEP %d: UPDATE NAT RULES", stepNum)
		case "definitions":
			sectionTitle = fmt.Sprintf("STEP %d: REMOVE REDUNDANT DEFINITIONS (do last)", stepNum)
		default:
			sectionTitle = fmt.Sprintf("STEP %d: %s", stepNum, strings.ToUpper(section))
		}

		fmt.Fprintf(file, "# %s\n", sectionTitle)
		fmt.Fprintf(file, "Found [%d] command", len(sectionCommands))
		if len(sectionCommands) != 1 {
			fmt.Fprintf(file, "s")
		}
		fmt.Fprintf(file, ":\n")
		fmt.Fprintf(file, "---\n")

		for _, command := range sectionCommands {
			fmt.Fprintf(file, "%s:\n", command.Description)
			fmt.Fprintf(file, "   └─ Command: %s\n", command.Command)
			fmt.Fprintf(file, "   └─ Section: %s\n", command.Section)
		}
		fmt.Fprintf(file, "---\n")
		stepNum++
	}

	fmt.Fprintf(file, "# USAGE INSTRUCTIONS\n")
	fmt.Fprintf(file, "---\n")
	if commands.TotalCommands == 0 {
		fmt.Fprintf(file, "No cleanup commands generated - redundant address may not be in use\n")
	} else {
		fmt.Fprintf(file, "1. Execute cleanup steps in the order shown above\n")
		fmt.Fprintf(file, "2. Remove definitions (delete commands) LAST to avoid breaking references\n")
		fmt.Fprintf(file, "3. Test all commands in non-production environment first\n")
		fmt.Fprintf(file, "4. Backup configuration before making changes\n")
		fmt.Fprintf(file, "---\n")
	}

	// Write actual commands at the bottom in results.yml style
	stepNum = 1
	for _, section := range sectionOrder {
		sectionCommands, exists := commandsBySection[section]
		if !exists || len(sectionCommands) == 0 {
			continue
		}

		// Get section title for commands
		var sectionTitle string
		switch section {
		case "target_creation":
			sectionTitle = fmt.Sprintf("STEP %d COMMANDS", stepNum)
		case "address_groups":
			sectionTitle = fmt.Sprintf("STEP %d COMMANDS", stepNum)
		case "security_rules":
			sectionTitle = fmt.Sprintf("STEP %d COMMANDS", stepNum)
		case "nat_rules":
			sectionTitle = fmt.Sprintf("STEP %d COMMANDS", stepNum)
		case "definitions":
			sectionTitle = fmt.Sprintf("STEP %d COMMANDS", stepNum)
		default:
			sectionTitle = fmt.Sprintf("STEP %d COMMANDS", stepNum)
		}

		fmt.Fprintf(file, "# %s\n", sectionTitle)
		fmt.Fprintf(file, "Found [%d] command", len(sectionCommands))
		if len(sectionCommands) != 1 {
			fmt.Fprintf(file, "s")
		}
		fmt.Fprintf(file, " to execute:\n")
		fmt.Fprintf(file, "---\n")
		for _, command := range sectionCommands {
			fmt.Fprintf(file, "%s\n", command.Command)
		}
		fmt.Fprintf(file, "---\n")
		stepNum++
	}

	// Add footer like results.yml
	fmt.Fprintf(file, "\n# ═══════════════════════════════════════════════════════════════\n")
	fmt.Fprintf(file, "# Cleanup Commands Generation Complete\n")
	fmt.Fprintf(file, "# Generated by: PAN Log Parser Tool v2.0 (Go Edition)\n")
	fmt.Fprintf(file, "# Advanced Redundant Address Cleanup & Optimization\n")
	fmt.Fprintf(file, "# ═══════════════════════════════════════════════════════════════\n")

	return nil
}

// getSectionDescription returns a description for each section
func getSectionDescription(section string) string {
	switch section {
	case "target_creation":
		return "Create target address in optimal scope for multi-DG usage"
	case "address_groups":
		return "Replace redundant addresses with target address in address groups"
	case "security_rules":
		return "Replace redundant addresses with target address in security rules"
	case "nat_rules":
		return "NAT rule updates require manual review due to complexity"
	case "definitions":
		return "Remove redundant address object definitions (execute last)"
	default:
		return "Configuration update step"
	}
}